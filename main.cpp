/*
 * ----------------------------------------------------------------------
 *  MAIN PROGRAM - generated by the Rappture Builder
 * ----------------------------------------------------------------------
 */

#include "rappture.h"

#include <string>
#include <sstream>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <unistd.h>

#include <Libnuceq.h>
#include <Libstatmech.h>
#include <WnMatrix.h>

#include <boost/lexical_cast.hpp>

double
neutrino_chemical_potential(
  Libnuceq *,
  double *
);

int
populate_vector(
  Libnuceq__Species *,
  gsl_vector *
);

int main(int argc, char * argv[]) {
    /* stuff needed for Rappture library */
    RpLibrary* io;
    const char* data; char s_equil[255]; char line[1024];

    double t9;
    double rho;
    double ye;
    double mu_nue_kT;
    double yh;
 
    Libnucnet__Nuc * p_nucnet;
    Libnuceq * p_equil;
    Libnuceq__Cluster * p_cluster;

    std::stringstream my_stream;

    /* open the XML file containing the run parameters */
    io = rpLibrary(argv[1]);

    if (io == NULL) {
        /* cannot open file or out of memory */
        printf("FAILED loading Rappture data\n");
        exit(1);
    }

    /*
     *********************************************************
     * Get input values from Rappture
     *********************************************************
     */
    
    /* get input value for input.choice(equil) */
    rpGetString(io,"input.choice(equil).current", &data);
    strcpy( s_equil, data );
    
    rpGetString(io,"input.number(t9).current", &data);
    t9 = atof(data);
    
    rpGetString(io,"input.number(rho).current", &data);
    rho = atof(data);
    
    rpGetString(io,"input.number(ye).current", &data);
    ye = atof(data);
    
    rpGetString(io,"input.number(mu_nue_kT).current", &data);
    mu_nue_kT = atof(data);
    
    rpGetString(io,"input.number(yh).current", &data);
    yh = atof(data);

    /*
     *********************************************************
     *  Main body of program.
     *********************************************************
     */

     p_nucnet =
       Libnucnet__Nuc__new_from_xml( "my_net.xml", "[z <= 60]" );

     p_equil = Libnuceq__new( p_nucnet );

     if( strcmp( s_equil, "wse" ) == 0 )
     {
       Libnuceq__updateWseCorrectionFunction(
         p_equil,
         (Libnuceq__wseCorrectionFunction)
            neutrino_chemical_potential,
         &mu_nue_kT
       );
     }
     if( strcmp( s_equil, "nse" ) == 0 )
     {
       Libnuceq__setYe( p_equil, ye );
     }
     if( strcmp( s_equil, "qse" ) == 0 )
     {
       Libnuceq__setYe( p_equil, ye );
       p_cluster =
         Libnuceq__newCluster( p_equil, "[z >= 6]" );
       Libnuceq__Cluster__updateConstraint( p_cluster, yh );
     }

     Libnuceq__computeEquilibrium( p_equil, t9, rho );

    /*
     *********************************************************
     * Create abundance vector vs. z.
     *********************************************************
     */

    size_t i_z_max =
      Libnucnet__Nuc__getLargestNucleonNumber(
        p_nucnet, "z"
      );

    gsl_vector * p_abundances =
      gsl_vector_calloc( i_z_max + 1 );

    Libnuceq__iterateSpecies(
      p_equil,
      (Libnuceq__Species__iterateFunction) populate_vector,
      p_abundances
    );

    my_stream <<
      "T9 = " << t9 << "  rho (g/cc) = " << rho << std::endl <<
      "Ye = " <<
      Libnuceq__computeZMoment( p_equil, 1 ) << std::endl <<
      "Neutron chemical potential / kT = " << 
      boost::lexical_cast<std::string>(
        Libnuceq__getMunkT( p_equil )
      ) << std::endl <<
      "Proton chemical potential / kT = " << 
      boost::lexical_cast<std::string>(
        Libnuceq__getMupkT( p_equil )
      ) << std::endl;

    /*
     *********************************************************
     * Save output values back to Rappture
     *********************************************************
     */
    
    for( size_t i = 0; i <= i_z_max; i++ )
    {
      sprintf(
	line,
	"%lu  %g\n",
	(unsigned long) i,
        gsl_vector_get( p_abundances, i )
      );
      rpPutString(io,"output.curve(abund).component.xy", line, RPLIB_APPEND);
    }

    rpPutString(
      io,
      "output.string(chem_pot).current",
      my_stream.str().c_str(),
      RPLIB_OVERWRITE
    );
      
    rpResult(io);

    Libnuceq__free( p_equil );
    Libnucnet__Nuc__free( p_nucnet );

    exit(0);
}

//##############################################################################
// neutrino_chemical_potential().
//##############################################################################

double
neutrino_chemical_potential(
  Libnuceq *p_equil,
  double *p_mu_nue_kT
)
{

  if( !p_equil )
  {
    fprintf( stderr, "Invalid equilibrium.\n" );
    exit( EXIT_FAILURE );
  }

  return *p_mu_nue_kT;

}

//##############################################################################
// neutrino_chemical_potential().
//##############################################################################

int
populate_vector(
  Libnuceq__Species * p_species,
  gsl_vector * p_abundances
)
{

  size_t i =
    Libnucnet__Species__getZ( Libnuceq__Species__getNucSpecies( p_species ) );

  gsl_vector_set(
    p_abundances,
    i,
    Libnuceq__Species__getAbundance( p_species )
    +
    gsl_vector_get( p_abundances, i )
  );
    
  return 1;

}
